1. 
expression → comma ;
comma      → equality ( "," equality )* ;
private Expr expression() {
return comma();
}
private Expr comma() {
Expr expr = equality();
while (match(COMMA)) {
Token operator = previous();
Expr right = equality();
expr = new Expr.Binary(expr, operator, right);
}
return expr;
}
Create a new check to maintain syntax of function calls with arguments.
if (!check(RIGHT_PAREN)) {
do {
if (arguments.size() >= 8) {
error(peek(), "Can't have more than 8 arguments.");
    		}
arguments.add(equality()); // <-- was expression().
} while (match(COMMA));
}



2. 
expression  → conditional ;
conditional → equality ( "?" expression ":" conditional )? ;

private Expr expression() {
return conditional();
}

private Expr conditional() {
Expr expr = equality();

  	if (match(QUESTION)) {
Expr thenBranch = expression();
consume(COLON, "Expect ':' after then branch of conditional expression.");
Expr elseBranch = conditional();
expr = new Expr.Conditional(expr, thenBranch, elseBranch);
  	}
return expr;
}
The precedence is lower than equality but higher than comma
The operator is right-associative.



3.
Revised primary
primary    → NUMBER | STRING | "true" | "false" | "nil"
           | "(" expression ")"
           | ( "!=" | "==" ) equality
           | ( ">" | ">=" | "<" | "<=" ) comparison
           | ( "+" ) term
           | ( "/" | "*" ) factor ;
private Expr primary() {
 	if (match(FALSE)) return new Expr.Literal(false);
 	if (match(TRUE)) return new Expr.Literal(true);
if (match(NIL)) return new Expr.Literal(null);

if (match(NUMBER, STRING)) {
    		return new Expr.Literal(previous().literal);
 	}
if (match(LEFT_PAREN)) {
Expr expr = expression();
consume(RIGHT_PAREN, "Expect ')' after expression.");
return new Expr.Grouping(expr);
  	}
if (match(BANG_EQUAL, EQUAL_EQUAL)) {
error(previous(), "Missing left-hand operand.");
equality();
return null;
}
  	if (match(GREATER, GREATER_EQUAL, LESS, LESS_EQUAL)) {
error(previous(), "Missing left-hand operand.");
comparison();
return null;
}
if (match(PLUS)) {
error(previous(), "Missing left-hand operand.");
term();
return null;
}
if (match(SLASH, STAR)) {
error(previous(), "Missing left-hand operand.");
factor();
return null;
}
throw error(peek(), "Expect expression.");
}
